---
title: IRRI and IRRef
sidebar:
  order: 4
---

How Pencel pairs IR with AST nodes and enables batch transformations.

## The Problem

Transformers need to update AST nodes based on IR state. `IRRef<T, TNode>` pairs each IR with its corresponding AST node.

## IRRef: IR + AST Pairing

`IRRef<T, TNode>` holds both IR and its corresponding AST node. Auto-registers with IRRI on creation:

```typescript
export class IRRef<T extends IR, TNode extends Node> {
  constructor(
    readonly ir: T,        // Immutable IR
    readonly node: TNode,  // AST node to transform
  ) {
    inject(IRRI).register(this)
  }
}
```

When you create an `IRRef`, it auto-registers with `IRRI`, enabling batch transformations.

## IRRI: Registry and Querying

`IRRI` collects all `IRRef` instances created during compilation:

```typescript
export class IRRI {
  allByKind<K extends IRKind>(kind: K): IRRef<KnownIRs[K], Node>[]
  firstIrr<K extends IRKind>(kind: K, filterFn: (item: KnownIRs[K]) => boolean): IRRef<KnownIRs[K], Node> | undefined
  implode<T extends IR>(irrs: IRRef<T, Node>[]): ImplodeIRRef<T>[]
}
```

**Key operations:**

- **Query by kind** – `irri.allByKind('Component')` → all component IRefs
- **Query with filter** – `irri.firstIrr('Component', (comp) => comp.tag === 'my-button')`
- **Implode** – `irri.implode(componentIRs)` → pure IR without AST nodes (for generators)

## Access Patterns

### Batch by Kind
Process all IRs of a specific kind:

```typescript
const components = irri.allByKind('Component')
for (const ref of components) {
  componentTransformer.transform(ref)
}
```

### Single IRRef
Work with one IR and its AST node:

```typescript
const ref = irri.allByKind('Component')[0]
const tag = ref.ir.tag              // Read IR
updateDecorator(ref.node, ref.ir)   // Update AST
```

### Pure IR Tree
Get the complete IR tree for generators (no AST):

```typescript
const components = irri.allByKind('Component')
const pureIR = irri.implode(components)  // ComponentIR[]
generateIRJSON(pureIR)
```

## Why This Design Matters

**Convenience** – Both IR and AST are together. No lookup needed.

**Batching** – IRRI enables efficient transformation: `irri.allByKind('Component')` processes all components at once.

**Clarity** – Each compilation pass rebuilds everything fresh, so IRRef is purely about convenience, not caching.

## The IRKind System

IRs are tracked by kind, and types are tracked centrally:

```typescript
export type IRKind = keyof KnownIRs

export type KnownIRs = {
  File: FileIR
  Component: ComponentIR
  Prop: PropertyIR
  Method: MethodIR
  Event: EventIR
  Render: RenderIR
}
```
