---
title: RenderIR
sidebar:
  order: 5
---

How Pencel represents JSX in render methods as a serializable intermediate representation.

## The Problem

Component `render()` methods return JSX, which TypeScript parses as AST nodes (`JsxElement`, `JsxSelfClosingElement`, etc.). But these AST nodes:

- Aren't serializable (contain circular references)
- Mix syntax with semantics (parentheses, whitespace)

**Solution:** Parse the JSX AST into a clean, serializable IR that mirrors the runtime VNode structure but remains framework-agnostic.

## RenderIR Structure

The `RenderIR` class extracts JSX from a component's `render()` method and builds a tree of serializable nodes:

```typescript
export class RenderIR extends IRM("Render") {
  readonly root: JSXRootIR | null;
  
  constructor(renderMember: MethodDeclaration) {
    super();
    const returnStatement = this.#findReturnStatement(renderMember);
    this.root = this.#parseJSXNode(returnStatement.expression);
  }
}
```

### JSX Node Kinds

Five node types cover all JSX constructs:

```typescript
enum JSXNodeKind {
  Element = "Element",           // <div>...</div> or <MyComponent>
  SelfClosing = "SelfClosing",   // <img /> or <slot />
  Fragment = "Fragment",         // <>...</>
  Text = "Text",                 // plain text content
  Expression = "Expression",     // {someVar} or {count + 1}
}
```

### Core Node Types

**JSXElementIR** - Full elements with children:

```typescript
interface JSXElementIR {
  kind: "Element";
  tagName: string;              // "div", "Host", "MyComponent"
  attributes: JSXAttributeIR[];
  children: JSXNodeIR[];
  isFunction: boolean;          // true for Host, uppercase names (functional components)
                                // false for lowercase names like "div", "span" (HTML elements)
}
```

**JSXSelfClosingIR** - Self-closing tags:

```typescript
interface JSXSelfClosingIR {
  kind: "SelfClosing";
  tagName: string;              // "img", "slot", "br"
  attributes: JSXAttributeIR[];
  isFunction: boolean;          // true for functional components, false for HTML elements
}
```

**JSXFragmentIR** - Fragment containers:

```typescript
interface JSXFragmentIR {
  kind: "Fragment";
  children: JSXNodeIR[];        // <>child1, child2</>
}
```

**JSXTextIR** - Static text:

```typescript
interface JSXTextIR {
  kind: "Text";
  text: string;                 // Trimmed content
}
```

**JSXExpressionIR** - Dynamic expressions:

```typescript
interface JSXExpressionIR {
  kind: "Expression";
  expression: string;           // Source text: "name", "count + 1"
  isSimple: boolean;            // true if just an identifier
}
```

### Attributes

Attributes come in two flavors: regular props and spreads.

**Regular Props:**

```typescript
interface JSXPropIR {
  type: "prop";
  name: string;
  value:
    | { type: "string"; value: string }      // className="foo"
    | { type: "expression"; value: string }  // onClick={handler}
    | { type: "true" };                      // disabled
}
```

**Spread Attributes:**

```typescript
interface JSXSpreadIR {
  type: "spread";
  expression: string;  // {...props}
}
```

## Example: Simple Component

Given this render method:

```tsx
render(): VNode {
  return (
    <Host>
      <slot />
    </Host>
  );
}
```

The `RenderIR` produces:

```json
{
  "kind": "Element",
  "tagName": "Host",
  "attributes": [],
  "children": [
    {
      "kind": "SelfClosing",
      "tagName": "slot",
      "attributes": [],
      "isFunction": false
    }
  ],
  "isFunction": true
}
```

## Example: Complex Attributes

```tsx
render(): VNode {
  return (
    <div className="container" data-id={this.id} disabled>
      <button onClick={this.handleClick} {...this.btnProps}>
        Click me
      </button>
    </div>
  );
}
```

Produces an IR with:

```json
{
  "kind": "Element",
  "tagName": "div",
  "attributes": [
    { "type": "prop", "name": "className", "value": { "type": "string", "value": "container" } },
    { "type": "prop", "name": "data-id", "value": { "type": "expression", "value": "this.id" } },
    { "type": "prop", "name": "disabled", "value": { "type": "true" } }
  ],
  "children": [
    {
      "kind": "Element",
      "tagName": "button",
      "attributes": [
        { "type": "prop", "name": "onClick", "value": { "type": "expression", "value": "this.handleClick" } },
        { "type": "spread", "expression": "this.btnProps" }
      ],
      "children": [
        { "kind": "Text", "text": "Click me" }
      ],
      "isFunction": false
    }
  ],
  "isFunction": false
}
```

## Parsing Strategy

The parser handles several edge cases:

### Parenthesized Expressions

JSX is often wrapped in parentheses. The parser unwraps them:

```typescript
#parseJSXNode(node: Expression): JSXRootIR | null {
  // Unwrap: return (<Host>...</Host>)
  if (node.kind === SyntaxKind.ParenthesizedExpression) {
    return this.#parseJSXNode(node.expression);
  }
  // ... continue parsing
}
```

### Component Detection

Tags starting with uppercase or named `Host` are functional components:

```typescript
#isFunctionComponent(tagName: string): boolean {
  if (tagName === "Host") return true;
  return tagName[0] === tagName[0]?.toUpperCase();
}
```

**Functional Components** (must be called):
- `Host` - special Pencel wrapper
- `MyButton`, `MyComponent` - uppercase names (user-defined components)

**HTML Elements** (created with `createElement`):
- `div`, `span`, `button` - lowercase names (standard HTML tags)

### Text Normalization

Whitespace-only text nodes are filtered out:

```typescript
if (child.kind === SyntaxKind.JsxText) {
  const text = child.text.trim();
  if (!text) return null;  // Skip whitespace
  return { kind: JSXNodeKind.Text, text };
}
```

## Integration with IRRI

Like other IR types, `RenderIR` extends `IRM("Render")` and is registered with IRRI:

```typescript
// In ComponentIR constructor
const renderMethod = members.find(m => m.name === 'render');
if (renderMethod) {
  const renderIR = new RenderIR(renderMethod);
  this.render = new IRRef(renderIR, renderMethod);  // Auto-registers
}
```

Query all render IRs:

```typescript
const allRenders = irri.allByKind('Render');
for (const { ir, node } of allRenders) {
  // ir: RenderIR
  // node: MethodDeclaration
  console.log(ir.root);  // Serializable JSX tree
}
```

## Use Cases

### Framework Adapters

Generate React components from the IR:

```typescript
function generateReact(renderIR: RenderIR): string {
  function visit(node: JSXNodeIR): string {
    if (node.kind === JSXNodeKind.Element) {
      const props = node.attributes.map(attr => 
        attr.type === 'prop' 
          ? `${attr.name}={${attr.value.value}}`
          : `{...${attr.expression}}`
      ).join(' ');
      const children = node.children.map(visit).join('');
      return `<${node.tagName} ${props}>${children}</${node.tagName}>`;
    }
    // ... handle other node types
  }
  return visit(renderIR.root);
}
```

### Patch Logic Generation

Transform declarative JSX into imperative DOM updates:

```typescript
function generatePatchFunction(renderIR: RenderIR): string {
  // Analyze IR to determine which parts are static vs dynamic
  const staticNodes = findStaticNodes(renderIR.root);
  const dynamicExpressions = findExpressions(renderIR.root);
  
  return `
    function patch(oldVNode, newVNode) {
      ${staticNodes.map(n => `// Skip diffing static: ${n.tagName}`).join('\n')}
      ${dynamicExpressions.map(e => `updateProp('${e.name}', ${e.expression})`).join('\n')}
    }
  `;
}
```

### Static Analysis

Analyze component structure without executing code:

```typescript
function analyzeRender(renderIR: RenderIR) {
  let totalNodes = 0;
  let dynamicExpressions = 0;
  const usedTags = new Set<string>();
  
  function walk(node: JSXNodeIR) {
    totalNodes++;
    if (node.kind === JSXNodeKind.Element || node.kind === JSXNodeKind.SelfClosing) {
      usedTags.add(node.tagName);
      node.attributes?.forEach(attr => {
        if (attr.type === 'prop' && attr.value.type === 'expression') {
          dynamicExpressions++;
        }
      });
    }
    if ('children' in node) {
      node.children?.forEach(walk);
    }
  }
  
  walk(renderIR.root);
  return { totalNodes, dynamicExpressions, usedTags };
}
```

### Validation

Ensure components follow best practices:

```typescript
function validateRender(renderIR: RenderIR): string[] {
  const errors: string[] = [];
  
  function validate(node: JSXNodeIR) {
    if (node.kind === JSXNodeKind.Element) {
      // Rule: Host must be root
      if (node.tagName === 'Host' && node !== renderIR.root) {
        errors.push('Host can only be used as root element');
      }
      
      // Rule: No inline styles
      node.attributes.forEach(attr => {
        if (attr.type === 'prop' && attr.name === 'style') {
          errors.push('Inline styles not allowed, use CSS classes');
        }
      });
      
      node.children?.forEach(validate);
    }
  }
  
  validate(renderIR.root);
  return errors;
}
```

## Design Principles

### Serializable by Default

All IR nodes are plain objects with no methods or circular references. This enables:

- JSON serialization for debugging
- Storage in `ir.json` generator output
- Easy transmission over network/IPC
- Snapshot testing

### Framework-Agnostic

The IR doesn't assume React, Angular, or any framework. It captures the semantic intent:

- What elements exist
- What their props are
- What their children are

Generators decide how to render this for each target.

### Mirrors Runtime Structure

The IR node types closely match runtime VNodes:

| IR Type | Runtime VNode |
|---------|---------------|
| `JSXElementIR` | `VTagNode` |
| `JSXSelfClosingIR` | `VTagNode` (no children) |
| `JSXFragmentIR` | `VFragmentNode` |
| `JSXTextIR` | `VTextNode` |
| `JSXExpressionIR` | Expression evaluated at runtime |

This makes it straightforward to generate runtime code that creates VNodes matching the IR.

### Expression Preservation

Dynamic expressions are stored as source text:

```typescript
// JSX: onClick={this.handleClick}
// IR: { type: "expression", value: "this.handleClick" }
```

This preserves the exact user code, enabling accurate code generation without re-parsing or AST manipulation.

## Next Steps

Potential enhancements:

1. **Source Maps** - Add `fileName`, `lineNumber`, `columnNumber` to each IR node for debugging
2. **Type Information** - Include resolved types for props and expressions
3. **Optimization Hints** - Mark static subtrees for AOT compilation
4. **Transformer** - Create `RenderTransformer` to rewrite JSX based on IR
5. **Validation Rules** - Built-in checks for accessibility, performance, best practices
